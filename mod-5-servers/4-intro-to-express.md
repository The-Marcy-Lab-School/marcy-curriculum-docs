# 1. Intro to Express

{% hint style="info" %}
Follow along with code examples [here](https://github.com/The-Marcy-Lab-School/5-2-intro-to-express)!
{% endhint %}

**Server-Side Development** is the part of software engineering that involves building server applications. Today, we'll begin learning about **Express**, the most popular Node framework for building HTTP server applications.

**Table of Contents:**

- [Essential Questions](#essential-questions)
- [Key Concepts](#key-concepts)
  - [Client Server Interactions Review](#client-server-interactions-review)
- [Express](#express)
  - [Connecting to your Server](#connecting-to-your-server)
- [Endpoints and Controllers](#endpoints-and-controllers)
  - [Controllers](#controllers)
  - [Query Parameters](#query-parameters)
  - [Using `req.query`](#using-reqquery)
  - [Query Parameter Challenge](#query-parameter-challenge)
- [Listening: Host and Ports](#listening-host-and-ports)


## Essential Questions

By the end of this lesson, you should be able to answer these questions:

1. What is Express and what problem does it solve compared to `node:http`?
2. What is an endpoint? What is a controller?
3. How do you define an endpoint and attach a controller using Express?
4. What are query parameters? How do you access them inside a controller?
5. What do `host` and `port` represent? What is `localhost`?

## Key Concepts

* **Server / Client** — a server is a computer that provides a service to another computer and its user, called the client.
* **HTTP Server Application** — a computer program that enables a computer to listen for and respond to HTTP requests.
* **Express** — the most popular Node framework for building HTTP server applications
* **Express `app`** — an object generated by Express that configures the http server application.
* **Host** and **Port** - the address of a server application
* **http://localhost** — the host when running a server application on your own computer
* **Endpoint** — a specific URL path of a server that clients can "hit" (send requests to) to create/read/update/delete data. For example: `/api/data` or `/api/users/:id`
* **Controller** — a callback function invoked asynchronously when the associated endpoint is targeted. It parses the request and sends back a response.
* **Query parameters** — a portion of a URL used to filter and sort the requested data.
  * Query Parameters are appended to the end of a URL with a `?` and separated with `&`
  * e.g. `/api/clothing/search?category=tops&sort=ascending`

### Client Server Interactions Review

A **server** is a computer that provides a service to another computer and its user, called the **client**.

**HTTP server applications** listen for and respond to HTTP requests coming from clients in the **client-server/request-response cycle:**

1. A client sends a **request** to the server
2. The server receives the request and determines what kind of **response** to send
3. The client receives the response and does something using the data!

![express diagram](./img/4-intro-to-express/express-diagram-simple.svg)

<details>

<summary><strong>Q: What are the responsibilities of a client application?</strong></summary>

* Rendering HTML, CSS, and JS
* Request information from a server (get requests)
* Providing information to a server (post/patch/delete requests)
* Reading data received from a server

</details>

<details>

<summary><strong>Q: What are the responsibilities of a server application?</strong></summary>

* Serving static files that live on the server (HTML, CSS, and JS files)
* Fetching and serving data from a third-party API that requires an API key
* Managing and serving data from the server's own database

</details>

## Express

In the last lesson, we learned how to build a server using the built-in `node:http` module. While we are able to build a working server this way, there are aspects using it that can feel clunky such as:
* Separating query parameters from paths
* Writing headers
* Routing

**Express** is a framework package that makes these things much easier. It is the most popular Node framework for building HTTP server applications.

To use express, we start by installing it as a dependency:

```sh
npm i express
```

The main export of Express is the `express` function which returns an object that we can use to configure the server application, often named `app`.

We typically start by setting the port on which the server will be "listening" with `app.listen()`:

```js
// index.js
const express = require('express');
const app = express();

const port = 8080; 

// run the server application on port 8080 of the current host (http://localhost during development)
app.listen(port); 
```

During development, the host is [http://localhost](http://localhost) so the server is listening at [http://localhost:8080](http://localhost:8080).

### Connecting to your Server

Try visiting [http://localhost:8080](http://localhost:8080) in your browser and you'll see that the site can't be reached. That's because we haven't turned our server on!

Run `node index.js` to start the server and visit [http://localhost:8080](http://localhost:8080) again. This time, you'll connect to your server! But nothing is being served yet — that's what we'll do next!

{% hint style="info" %}
When we deploy this application on a server hosting service, our code stays the same but our host will change! The deployment service typically will handle assigning the application a port.
{% endhint %}

## Endpoints and Controllers

When we send a request to an API, we typically will send the request to a specific endpoint, such as [https://dog.ceo/api/breeds/image/random](https://dog.ceo/api/breeds/image/random). The API may provide multiple endpoints that each respond differently, such as [https://dog.ceo/api/breeds/list/all](https://dog.ceo/api/breeds/list/all).

When we send a request to an API, say [https://dog.ceo](https://dog.ceo), the API's server application defines

1. The endpoints that clients can send requests to ([api/breeds/image/random](https://dog.ceo/api/breeds/image/random) or [/api/breeds/list/all](https://dog.ceo/api/breeds/list/all))
2. How each endpoint will respond (with a random image or a list of all dog breeds)

When designing our own API's with express, we add **endpoints** and **controllers** using the `app.get(endpoint, controller)` method.

* The `endpoint` parameter is a string that determines where on the server the client can send a request to
* The `controller` parameter is a callback function that is invoked asynchronously when the associated endpoint is requested. They determine how the server responds.

```js
const express = require('express');
const app = express();

// All endpoints start at `/` which is the "root" of the server
app.get('/', (req, res, next) => {
  res.send('You are connected!');
})

// Typically, we start endpoints with `/api` to separate data endpoints from static asset endpoints
app.get('/api/hello', (req, res, next) => {
  res.send('Hello');
})

const port = 8080; 
app.listen(port); 
```

All endpoints are appended to the host and port.

* When the server is listening at `http://localhost:8080`, the `/` endpoint is accessible at `http://localhost:8080/`
* When the server is listening at `http://localhost:8080`, the `/api/hello` endpoint is accessible at `http://localhost:8080/api/hello`

{% hint style="info" %}
When you visit `http://localhost:8080`, you are technically hitting the `/` endpoint (the `/` is implied)
{% endhint %}

### Controllers

A **Controller** is a callback function invoked asynchronously when the associated endpoint is targeted. It parses the request and sends back a response.

{% hint style="info" %}
To keep things organized, it is a best practice to write controllers as named functions.
{% endhint %}

Every controller is provided with three values (`req`, `res`, and `next`) though all three aren't always used by the controller:

```js
const serveHello = (req, res, next) => {
  res.send({ message: 'hello'});
}
const serveData = (req, res, next) => {
  const data = [{ name: 'ben' }, { name: 'zo' }, { name: 'carmen' }];
  res.send(data);
}
const serveStatus = (req, res, next) => {
  res.sendStatus(200);
}

app.get('/api/hello', serveHello);
app.get('/api/data', serveData);
app.get('/api/ping', serveStatus);
```

The `res` parameter is an object with methods for configuring the response we want to send to the client.

* The `res.send` method allows us to send data to the client.
* The `res.sendStatus` method lets us send just a status code without data.

These controllers are quite simple as they just send back a pre-defined response, but controllers can do quite complex tasks!

The `next` parameter will be discussed in the next lesson, but what about the `req` parameter?

### Query Parameters

The `req` parameter is an object containing information about the incoming request. One way we can make use of the request object `req` is by accepting query parameters.

**Query parameters** are added to the end of request URL to tell the server to modify the requested data in some way. They are often used for search queries or to filter results. Google adds a `q` query parameter when you provide a search query:

[https://www.google.com/search?q=express+node](https://www.google.com/search?q=express%20node)

Query parameters are added in `key=value` pairs to the end of a URL following a `?`. In the example above `q` is the name of the query parameter with the value `express+node` (the `+` is just used to indicate a space).

When multiple query parameters are needed, they are each separated by an ampersand `&`. For example, if we wanted to include a `first` and `last` name to the `/api/hello` endpoint, we could write:

[localhost:8080/api/hello?first=ben\&last=spector](https://localhost:8080/api/hello?first=ben\&last=spector)

### Using `req.query`

In the controller code, each `key=value` query parameter will show up in the `req.query` object with a string value.

So, we can modify our `serveHello` controller like so:

```js
const serveHello = (req, res, next) => {
  console.log(req.query); // { first: "ben", last: "spector" }

  const { first, last} = req.query;
  
  if (!first || !last) {
    return res.send({ message: `hello stranger!`});
  }
  res.send({ message: `hello ${first} ${last}!`});
}

app.get('/api/hello', serveHello);
```

* In this example, we get the `first` and `last` values by destructuring the `req.query` object.
* Before sending a response, we make sure to check that both query parameters are provided, otherwise we just send `'hello stranger!'`.

### Query Parameter Challenge

How can we modify the `serveData` function so that it filters the array of objects by the `.name` property using a `?filter=value` query parameter?

<details>

<summary><strong>Solution</strong></summary>

```js
const serveData = (req, res, next) => {
  const filter = req.query.filter
  const data = [{ name: 'ben' }, { name: 'zo' }, { name: 'carmen' }];

  if (!filter) res.send(data);
  const filteredData = data.filter((item) => item.name === filter);
  res.send(filteredData);
}
```

</details>

## Listening: Host and Ports

The last lines of code "turn on" the server. That is, they make the server start listening for requests.

```js
const port = 8080;
app.listen(port, () => console.log(`listening at http://localhost:${port}`)); 
```

* The first argument defines the **port** number
* The second argument is a callback that gets executed when the server starts listening. It is often used to print out the host and port.

![host port](./img/4-intro-to-express/host-port.png)

The **host** is like our home address.

* `localhost` is a hostname that refers to the current device used to access it.
* `localhost` is an alias for `127.0.0.1` which is the standard address used.
* `localhost === 127.0.0.1`

Ports are the "front doors" of our application. (There are a lot of doors!)

* `:8080` is considered as a different "door" from `:5500`

Which port should you use? It doesn't really matter, but here are some ones that our instructors like to use and some standards that are used:

* `8080` (What I use)
* `4321` (Mike's favorite because it is fun)
* `3000` (What other people use)
* `5500` (What other other people use)
* `80` (Standard unencrypted HTTP port)
* `443` (Standard encrypted HTTPS port)

Just pick one that isn't being used!

> How do you know which ones aren't being used? Your computer will likely tell you if one is currently in use — just use a different one (or kill the process that is currently using that port).
